from sort_selection import *
import copy

"""old_exploitation, delete"""
# def exploitation(population, individuals, _exploit, _exploit_param, _twins):
#     if _exploit == '000':
#         """nPX"""
#         off_spring = npx(population, individuals, _exploit_param, _twins)
#     elif _exploit == '001':
#         """UX"""
#         off_spring = ux(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '010':
#         """AX"""
#         off_spring = ax(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '011':
#         """PSO"""
#         off_spring = pso_exploit(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '100':
#         """safari"""
#         off_spring = safari(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '101':
#         """commensalism"""
#         off_spring = commensalism(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '110':
#         """DE/Rand"""
#         off_spring = de_rand(population, individuals, _exploit_param, _twins)
#
#     else:
#         """DE/Best"""
#         off_spring = de_best(population, individuals, _exploit_param, _twins)
#
#     return off_spring


def npx(population, individuals, _exploit_param, _twins):
    if len(population.selection_cache) == 2:
        population.selection_cache.append(np.arange(2, population.num_cp, 1))
    # points = []
    control_points_r = [individuals[0].control_points_r[0].reshape(1, 3),
                        individuals[1].control_points_r[0].reshape(1, 3)]
    pre_point = 1
    count = False
    index = np.random.choice(population.selection_cache[2], size=_exploit_param, replace=False)
    index = np.sort(index)
    # for cnt in range(_exploit_param):
    #     index = np.random.randint(2, population.num_cp)
    #     if index not in points:
    #         points.append(index)
    # points.append(population.num_cp)
    # points.sort()
    for each in index:
        control_points_r[0] = np.concatenate((control_points_r[0],
                                              individuals[not count].control_points_r[pre_point:each]), axis=0)
        control_points_r[1] = np.concatenate((control_points_r[1],
                                              individuals[count].control_points_r[pre_point:each]), axis=0)
        count = not count
        pre_point = each
    off_spring = np.array([Individual(population, control_points_r[0]), Individual(population, control_points_r[1])])
    if not int(_twins):
        off_spring = np.delete(population.sort(off_spring), 1)
    return off_spring


def ux(population, individuals, _exploit_param, _twins):
    # if population.exploit_param is None:
    #     if _exploit_param == '00':
    #         population.exploit_param = ['UX', 0.5]
    #     if _exploit_param == '01':
    #         population.exploit_param = ['UX', 0.6]
    #     if _exploit_param == '10':
    #         population.exploit_param = ['UX', 0.7]
    #     if _exploit_param == '11':
    #         population.exploit_param = ['UX', 0.8]

    parents = np.array([individuals[0].control_points_r,
                        individuals[1].control_points_r])

    inx_a = np.array([0, 1])
    b = np.arange(0, len(individuals[0].control_points_r), 1)
    inx = np.random.choice(inx_a, len(individuals[0].control_points_r))
    control_points_a = parents[inx, b]
    off_spring = [Individual(population, control_points_a)]
    # for cnt in range(1, population.num_cp):
    #     if np.random.rand() < _exploit_param:
    #         control_points_r[0] = np.concatenate((control_points_r[0],
    #                                               individuals[1].control_points_r[cnt:cnt+1]), axis=0)
    #         control_points_r[1] = np.concatenate((control_points_r[1],
    #                                               individuals[0].control_points_r[cnt:cnt+1]), axis=0)
    #     else:
    #         control_points_r[0] = np.concatenate((control_points_r[0],
    #                                               individuals[0].control_points_r[cnt:cnt+1]), axis=0)
    #         control_points_r[1] = np.concatenate((control_points_r[1],
    #                                               individuals[1].control_points[cnt:cnt+1]), axis=0)
    # off_spring = [Individual(population, control_points_r[0]), Individual(population, control_points_r[1])]
    if int(_twins):
        control_points_b = parents[1 * np.logical_not(inx), b]
        off_spring.append(Individual(population, control_points_b))
    return np.array(off_spring)


def ax(population, individuals, _exploit_param, _twins):
    parents = np.array([individuals[0].control_points_r,
                        individuals[1].control_points_r])
    off_spring = [Individual(population, parents[0] * _exploit_param + parents[1] * (1 - _exploit_param))]
    return np.array(off_spring)


def pso_exploit(population, individuals, _exploit_param, _twins):
    """Individuals: list - two parts: individual including its personal_best, global_best"""
    w, c_1, c_2 = population.exploitation_params
    r_1, r_2 = np.random.rand(2)
    velocity = w * individuals[0].velocity + \
                              c_1 * r_1 * (individuals[0].p_best.control_points_r -
                                           individuals[0].control_points_r) + \
                              c_2 * r_2 * (individuals[1].control_points_r - individuals[0].control_points_r)
    new_control_points_r = individuals[0].control_points_r + velocity
    off_spring = np.array([Individual(population, new_control_points_r)])
    off_spring[0].velocity = velocity
    if population.sort(np.array([off_spring[0], individuals[0]]))[0] == individuals[0]:
        off_spring[0].p_best = individuals[0]
    return off_spring


def safari(population, individuals, _exploit_param, _twins):
    safari_wolves = individuals[0: int(individuals.size * _exploit_param + 1)]
    safari_result = perturbation(safari_wolves)
    leader_wolves = np.array([])
    for each in safari_result:
        leader_wolves = np.append(leader_wolves, Individual(population, each))
    leader_wolves = population.sort(leader_wolves)
    g_best = leader_wolves[0].control_points_r
    p_t = np.array([individuals[x].control_points_r for x in range(individuals.size)])
    a_ = g_best - p_t
    b_ = np.abs(a_)
    p_new = p_t + np.divide(a_, b_, out=np.zeros_like(a_), where=b_ != 0)
    off_spring = np.array([])
    for each in p_new:
        off_spring = np.append(off_spring, Individual(population, each))
    return off_spring


def perturbation(individuals):
    control_points_r_safari = np.array([individuals[x].control_points_r for x in range(individuals.size)])
    disturbing_term = np.random.normal(0, 0.2, size=control_points_r_safari.shape)
    disturbing_term[:, :, 0] = 0
    disturbing_term[:, 0, :] = 0
    disturbing_term[:, -1, :] = 0
    control_points_r_safari += disturbing_term
    return control_points_r_safari


def commensalism(population, individuals, _exploit_param, _twins):
    p_i = individuals[0].control_points_r
    p_j = individuals[1].control_points_r
    return off_spring


def de_rand(population, individuals, _exploit_pram, _twins):
    off_spring = []
    # TODO
    return off_spring


def de_best(population, individuals, _exploit_param, _twins):
    off_spring = []
    # TODO
    return off_spring


def exploration(population, individuals, _explore, _explore_param, _infer):
    if _explore == '000':
        """Non-Uniform Mutation"""
        off_spring = num(population, individuals, _explore_param, _infer)
    elif _explore == '001':
        """Uniform Mutation"""
        off_spring = um(population, individuals, _explore_param, _infer)

    elif _explore == '010':
        """Gaussian Mutation"""
        off_spring = gm(population, individuals, _explore_param, _infer)

    elif _explore == '011':
        """Cauchy Mutation"""
        off_spring = cm(population, individuals, _explore_param, _infer)

    elif _explore == '100':
        """population updating strategy"""
        off_spring = pus(population, individuals, _explore_param, _infer)

    elif _explore == '101':
        """simplified gray wolf optimizer"""
        off_spring = sgwo(population, individuals, _explore_param, _infer)

    elif _explore == '110':
        """collective information"""
        off_spring = cinf(population, individuals, _explore_param, _infer)

    else:
        """None"""
        off_spring = individuals

    return off_spring


def infer(population, genomes, variants):
    count = 0
    for variant in variants:
        # if penalty_function(population.gen_max, variant.fitness_wight_factor,
        #                     variant.constraint, population.generation, '000') > \
        #         penalty_function(population.gen_max, genomes[count].fitness_wight_factor,
        #                          genomes[count].constraint, population.generation, '000'):
        if 1:
            # TODO
            variants[count] = genomes[count]
        count += 1
    return variants


def um(population, genomes, _explore_param, _infer):
    if population.explore_param is None:
        if _explore_param == '00':
            population.explore_param = ['UM', 0.5 / population.num_cp, 1]
        if _explore_param == '01':
            population.explore_param = ['UM', 0.5 / population.num_cp, 2]
        if _explore_param == '10':
            population.explore_param = ['UM', 0.5 / population.num_cp * np.log2(population.generation), 1]
        if _explore_param == '11':
            population.explore_param = ['UM', 0.5 / population.num_cp * np.log2(population.generation), 2]
    variants = copy.deepcopy([genomes[x].control_points for x in range(len(genomes))])
    delta_l = variants[0][1][0] - variants[0][0][0]
    count = 0
    for variant in variants:
        for cnt in range(1, population.num_cp - 1):
            if np.random.rand() < population.explore_param[1]:
                if population.explore_param[2] == 1:
                    x = variant[cnt-1][0] + np.random.uniform(-delta_l,  delta_l)
                    y = variant[cnt-1][1] + np.random.uniform(-delta_l, delta_l)
                    z = variant[cnt-1][2] + np.random.uniform(-delta_l, delta_l)
                else:
                    x = variant[cnt-1][0] + np.random.normal(0, delta_l / 3)
                    y = variant[cnt-1][1] + np.random.normal(0, delta_l / 3)
                    z = variant[cnt-1][2] + np.random.normal(0, delta_l / 3)
                variant[cnt] = np.array([x, y, z])
        variants[count] = Individual(population, variant)
        count += 1

    if not int(_infer):
        variants = infer(population, genomes, variants)
    return variants


def num(population, genomes, _explore_param, _infer):
    if population.explore_param is None:
        if _explore_param == '00':
            population.explore_param = ['NUM', 0.5 / population.num_cp, 1]
        if _explore_param == '01':
            population.explore_param = ['NUM', 0.5 / population.num_cp, 2]
        if _explore_param == '10':
            population.explore_param = ['NUM', 0.5 / population.num_cp * np.log2(population.generation), 1]
        if _explore_param == '11':
            population.explore_param = ['NUM', 0.5 / population.num_cp * np.log2(population.generation), 2]
    variants = copy.deepcopy([genomes[x].control_points_r for x in range(len(genomes))])
    count = 0
    for variant in variants:
        for cnt in range(1, population.num_cp - 1):
            if np.random.rand() < population.explore_param[1]:
                x = 0
                y = np.random.uniform(-population.explore_param[2], population.explore_param[2])
                z = np.random.uniform(-population.explore_param[2], population.explore_param[2])
                variant[cnt] += np.array([x, y, z])
        variants[count] = Individual(population, variant)
        count += 1

    if not int(_infer):
        variants = infer(population, genomes, variants)
    return variants


def gm(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def cm(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def pus(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def sgwo(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def cinf(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


if __name__ == '__main__':
    p = test()
    individual = []
    sort(p, '10', '111')
    for i in range(2):
        individual.append(selection(p, '10', '11'))
    off_springs = exploitation(p, individual, '001', '10', '0')
    variants = exploration(p, individual, '000', '00', '0')