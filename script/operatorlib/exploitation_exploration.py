from sort_selection import *
import copy

"""old_exploitation, delete"""
# def exploitation(population, individuals, _exploit, _exploit_param, _twins):
#     if _exploit == '000':
#         """nPX"""
#         off_spring = npx(population, individuals, _exploit_param, _twins)
#     elif _exploit == '001':
#         """UX"""
#         off_spring = ux(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '010':
#         """AX"""
#         off_spring = ax(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '011':
#         """PSO"""
#         off_spring = pso_exploit(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '100':
#         """safari"""
#         off_spring = safari(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '101':
#         """commensalism"""
#         off_spring = commensalism(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '110':
#         """DE/Rand"""
#         off_spring = de_rand(population, individuals, _exploit_param, _twins)
#
#     else:
#         """DE/Best"""
#         off_spring = de_best(population, individuals, _exploit_param, _twins)
#
#     return off_spring


def instantiation(population, control_points_r):
    individuals = np.array([])
    for each in control_points_r:
        individuals = np.append(individuals, Individual(population, each))
    return individuals


def npx(population, inx, _exploit_param):
    selection_cache = np.arange(2, population.num_cp, 1)
    control_points_r = population.data[inx]
    index = np.random.choice(selection_cache, size=_exploit_param, replace=False).reshape(1, -1)
    pairs = inx.size//2
    for x in range(1, pairs):
        index = np.concatenate((
            index, np.random.choice(selection_cache, size=_exploit_param, replace=False).reshape(1, -1)))
    index = np.sort(index, axis=1)
    index = np.concatenate((
                            index, np.ones([pairs, 1], dtype=np.int32) * population.num_cp), axis=1)
    flag = True
    pre_inx = index[:, 0]
    for x in range(1, index.shape[1]):
        current_inx = index[:, x]
        if flag is True:
            control_points_r = switch(control_points_r, pre_inx, current_inx)
        flag = not flag
        pre_inx = current_inx
    return control_points_r


def switch(control_points_r, pre_inx, current_inx):
    for x in range(pre_inx.size):
        clip_1 = control_points_r[x*2, pre_inx[x]:current_inx[x]].copy()
        control_points_r[x*2, pre_inx[x]:current_inx[x]] = control_points_r[x*2+1, pre_inx[x]:current_inx[x]]
        control_points_r[x*2 + 1, pre_inx[x]:current_inx[x]] = clip_1
    return control_points_r

# def npx(population, inx, _exploit_param, _twins):
#     if len(population.selection_cache) == 2:
#         population.selection_cache.append(np.arange(2, population.num_cp, 1))
#     # points = []
#     control_points_r = [inx[0].control_points_r[0].reshape(1, 3),
#                         inx[1].control_points_r[0].reshape(1, 3)]
#     pre_point = 1
#     count = False
#     index = np.random.choice(population.selection_cache[2], size=_exploit_param, replace=False)
#     index = np.sort(index)
#     for each in index:
#         control_points_r[0] = np.concatenate((control_points_r[0],
#                                               inx[not count].control_points_r[pre_point:each]), axis=0)
#         control_points_r[1] = np.concatenate((control_points_r[1],
#                                               inx[count].control_points_r[pre_point:each]), axis=0)
#         count = not count
#         pre_point = each
#     off_spring = np.array([Individual(population, control_points_r[0]), Individual(population, control_points_r[1])])
#     if not int(_twins):
#         off_spring = np.delete(population.sort(off_spring), 1)
#     return off_spring


def ux(population, inx, _exploit_param):
    control_points_r = population.data[inx]
    ux_basis = np.array([0, 1])
    b = np.arange(0, population.num_cp, 1)
    index_ux = np.random.choice(ux_basis, (inx.size // 2, population.num_cp))
    index_ux = index_ux.repeat(2, axis=0).reshape(-1, index_ux.shape[1])
    index_ux[0:-1:2][:] = np.logical_not(index_ux[0:-1:2][:])
    for x in range(index_ux.shape[0] // 2):
        index_ux[2*x][:] += 2*x
        index_ux[2*x+1][:] += 2*x
    control_points_ux = control_points_r[index_ux, b]
    return control_points_ux


def ax(population, inx, _exploit_param):
    control_points_r = population.data[inx]
    x = np.arange(0, inx.size, 2)
    y = x + 1
    control_points_ax = control_points_r[x] * _exploit_param + control_points_r[y] * (1 - _exploit_param)
    return control_points_ax


def pso_exploit(population, inx, _exploit_param):
    """Individuals: list - two parts: individual including its personal_best, global_best"""
    control_points_r = population.data[inx]
    param_max = np.array([0.9, _exploit_param[1]])
    param_min = np.array([0.4, _exploit_param[0]])
    w, c_1 = param_max - (param_max - param_min) * population.generation / population.gen_max
    c_2 = param_max[1] + (param_max[1] - param_min[1]) * population.generation / population.gen_max
    r_1, r_2 = np.random.rand(2, inx.size)

    g_best = population.data[0]
    r_1 = np.repeat(r_1, g_best.size).reshape((inx.size,
                                              g_best.shape[0], g_best.shape[1]))
    r_2 = np.repeat(r_2, g_best.size).reshape((inx.size,
                                              g_best.shape[0], g_best.shape[1]))
    # TODO
    velocity = population.velocity[inx]
    p_best = population.p_best[inx]
    velocity = (w * velocity + c_1 * r_1 * (p_best - control_points_r) +
                    c_2 * r_2 * (g_best - control_points_r))
    # velocity = []
    # for x in range(inx.size):
    #     velocity.append(w * population.individuals[inx[x]].velocity +
    #                     c_1 * r_1[x] * (population.individuals[inx[x]].p_best.control_points_r -
    #                                     population.data[inx[x]]) +
    #                     c_2 * r_2[x] * (g_best - population.data[inx[x]]))
    # velocity = np.array(velocity)
    new_control_points_r = control_points_r + velocity
    population.velocity = velocity
    return new_control_points_r


def safari(population, inx, _exploit_param):
    safari_wolves_inx = np.arange(0, np.int(population.num_individual * _exploit_param + 1), 1)
    safari_result = perturbation(population, safari_wolves_inx)
    leader_wolves = instantiation(population, safari_result)
    inx_wolves = population.sort(leader_wolves)
    g_best = safari_result[inx_wolves[0]]
    p_t = population.data[inx]
    a_ = g_best - p_t
    b_ = np.abs(a_)
    p_new = p_t + np.divide(a_, b_, out=np.zeros_like(a_), where=b_ != 0)
    return p_new


def perturbation(population, inx):
    control_points_r_safari = population.data[inx]
    disturbing_term = np.random.normal(0, 0.2, size=control_points_r_safari.shape)
    disturbing_term[:, :, 0] = 0
    disturbing_term[:, 0, :] = 0
    disturbing_term[:, -1, :] = 0
    control_points_r_safari += disturbing_term
    return control_points_r_safari


def commensalism(population, inx, _exploit_param):
    x = np.arange(0, inx.size, 2)
    y = x + 1
    p_i = population.data[inx[x]]
    p_j = population.data[inx[y]]
    g_best = population.data[0]
    r = eval(_exploit_param + "size=" + str(inx.size) + ")")
    r = np.repeat(r, g_best.size).reshape((-1, g_best.shape[0], g_best.shape[1]))
    r_1 = r[0: r.shape[0]//2]
    r_2 = r[r.shape[0]//2::]
    p_new_1 = p_i + r_1 * (g_best - p_j)
    p_new_2 = p_j + r_2 * (g_best - p_i)
    control_points_commensalism = np.array([p_new_1[0], p_new_2[0]])
    for x in range(1, p_new_1.shape[0]):
        control_points_commensalism = np.concatenate((control_points_commensalism, np.array([p_new_1[x], p_new_2[x]])))
    # individuals_commensalism = instantiation(population, control_points_commensalism)
    # for x in range(inx.size):
    #     if population.sort(np.array(
    #             [individuals_commensalism[x], population.individuals[inx[x]]]))[0] == 1:
    #         control_points_commensalism[x] = population.data[inx[x]].copy()
    return control_points_commensalism


def de_rand(population, inx, _exploit_param):
    control_points_r = population.data[inx]
    
    # TODO
    return off_spring


def de_best(population, inx, _exploit_param):
    off_spring = []
    # TODO
    return off_spring


def exploration(population, individuals, _explore, _explore_param, _infer):
    if _explore == '000':
        """Non-Uniform Mutation"""
        off_spring = num(population, individuals, _explore_param, _infer)
    elif _explore == '001':
        """Uniform Mutation"""
        off_spring = um(population, individuals, _explore_param, _infer)

    elif _explore == '010':
        """Gaussian Mutation"""
        off_spring = gm(population, individuals, _explore_param, _infer)

    elif _explore == '011':
        """Cauchy Mutation"""
        off_spring = cm(population, individuals, _explore_param, _infer)

    elif _explore == '100':
        """population updating strategy"""
        off_spring = pus(population, individuals, _explore_param, _infer)

    elif _explore == '101':
        """simplified gray wolf optimizer"""
        off_spring = sgwo(population, individuals, _explore_param, _infer)

    elif _explore == '110':
        """collective information"""
        off_spring = cinf(population, individuals, _explore_param, _infer)

    else:
        """None"""
        off_spring = individuals

    return off_spring


def infer(population, genomes, variants):
    count = 0
    for variant in variants:
        # if penalty_function(population.gen_max, variant.fitness_wight_factor,
        #                     variant.constraint, population.generation, '000') > \
        #         penalty_function(population.gen_max, genomes[count].fitness_wight_factor,
        #                          genomes[count].constraint, population.generation, '000'):
        if 1:
            # TODO
            variants[count] = genomes[count]
        count += 1
    return variants


def um(population, genomes, _explore_param, _infer):
    if population.explore_param is None:
        if _explore_param == '00':
            population.explore_param = ['UM', 0.5 / population.num_cp, 1]
        if _explore_param == '01':
            population.explore_param = ['UM', 0.5 / population.num_cp, 2]
        if _explore_param == '10':
            population.explore_param = ['UM', 0.5 / population.num_cp * np.log2(population.generation), 1]
        if _explore_param == '11':
            population.explore_param = ['UM', 0.5 / population.num_cp * np.log2(population.generation), 2]
    variants = copy.deepcopy([genomes[x].control_points for x in range(len(genomes))])
    delta_l = variants[0][1][0] - variants[0][0][0]
    count = 0
    for variant in variants:
        for cnt in range(1, population.num_cp - 1):
            if np.random.rand() < population.explore_param[1]:
                if population.explore_param[2] == 1:
                    x = variant[cnt-1][0] + np.random.uniform(-delta_l,  delta_l)
                    y = variant[cnt-1][1] + np.random.uniform(-delta_l, delta_l)
                    z = variant[cnt-1][2] + np.random.uniform(-delta_l, delta_l)
                else:
                    x = variant[cnt-1][0] + np.random.normal(0, delta_l / 3)
                    y = variant[cnt-1][1] + np.random.normal(0, delta_l / 3)
                    z = variant[cnt-1][2] + np.random.normal(0, delta_l / 3)
                variant[cnt] = np.array([x, y, z])
        variants[count] = Individual(population, variant)
        count += 1

    if not int(_infer):
        variants = infer(population, genomes, variants)
    return variants


def num(population, genomes, _explore_param, _infer):
    if population.explore_param is None:
        if _explore_param == '00':
            population.explore_param = ['NUM', 0.5 / population.num_cp, 1]
        if _explore_param == '01':
            population.explore_param = ['NUM', 0.5 / population.num_cp, 2]
        if _explore_param == '10':
            population.explore_param = ['NUM', 0.5 / population.num_cp * np.log2(population.generation), 1]
        if _explore_param == '11':
            population.explore_param = ['NUM', 0.5 / population.num_cp * np.log2(population.generation), 2]
    variants = copy.deepcopy([genomes[x].control_points_r for x in range(len(genomes))])
    count = 0
    for variant in variants:
        for cnt in range(1, population.num_cp - 1):
            if np.random.rand() < population.explore_param[1]:
                x = 0
                y = np.random.uniform(-population.explore_param[2], population.explore_param[2])
                z = np.random.uniform(-population.explore_param[2], population.explore_param[2])
                variant[cnt] += np.array([x, y, z])
        variants[count] = Individual(population, variant)
        count += 1

    if not int(_infer):
        variants = infer(population, genomes, variants)
    return variants


def gm(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def cm(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def pus(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def sgwo(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def cinf(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


if __name__ == '__main__':
    p = test()
    individual = []
    sort(p, '10', '111')
    for i in range(2):
        individual.append(selection(p, '10', '11'))
    off_springs = exploitation(p, individual, '001', '10', '0')
    variants = exploration(p, individual, '000', '00', '0')