from sort_selection import *
import numpy as np
import copy

"""old_exploitation, delete"""
# def exploitation(population, individuals, _exploit, _exploit_param, _twins):
#     if _exploit == '000':
#         """nPX"""
#         off_spring = npx(population, individuals, _exploit_param, _twins)
#     elif _exploit == '001':
#         """UX"""
#         off_spring = ux(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '010':
#         """AX"""
#         off_spring = ax(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '011':
#         """PSO"""
#         off_spring = pso_exploit(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '100':
#         """safari"""
#         off_spring = safari(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '101':
#         """commensalism"""
#         off_spring = commensalism(population, individuals, _exploit_param, _twins)
#
#     elif _exploit == '110':
#         """DE/Rand"""
#         off_spring = de_rand(population, individuals, _exploit_param, _twins)
#
#     else:
#         """DE/Best"""
#         off_spring = de_best(population, individuals, _exploit_param, _twins)
#
#     return off_spring


def instantiation(population, control_points_r):
    individuals = np.array([])
    for each in control_points_r:
        individuals = np.append(individuals, Individual(population, each))
    return individuals


def npx(population, inx, _exploit_param):
    selection_cache = np.arange(2, population.num_cp, 1)
    control_points_r = population.data[inx]
    index = np.random.choice(selection_cache, size=_exploit_param, replace=False).reshape(1, -1)
    pairs = inx.size//2
    for x in range(1, pairs):
        index = np.concatenate((
            index, np.random.choice(selection_cache, size=_exploit_param, replace=False).reshape(1, -1)))
    index = np.sort(index, axis=1)
    index = np.concatenate((
                            index, np.ones([pairs, 1], dtype=np.int32) * population.num_cp), axis=1)
    flag = True
    pre_inx = index[:, 0]
    for x in range(1, index.shape[1]):
        current_inx = index[:, x]
        if flag is True:
            control_points_r = switch(control_points_r, pre_inx, current_inx)
        flag = not flag
        pre_inx = current_inx
    return control_points_r


def switch(control_points_r, pre_inx, current_inx):
    for x in range(pre_inx.size):
        clip_1 = control_points_r[x*2, pre_inx[x]:current_inx[x]].copy()
        control_points_r[x*2, pre_inx[x]:current_inx[x]] = control_points_r[x*2+1, pre_inx[x]:current_inx[x]]
        control_points_r[x*2 + 1, pre_inx[x]:current_inx[x]] = clip_1
    return control_points_r

# def npx(population, inx, _exploit_param, _twins):
#     if len(population.selection_cache) == 2:
#         population.selection_cache.append(np.arange(2, population.num_cp, 1))
#     # points = []
#     control_points_r = [inx[0].control_points_r[0].reshape(1, 3),
#                         inx[1].control_points_r[0].reshape(1, 3)]
#     pre_point = 1
#     count = False
#     index = np.random.choice(population.selection_cache[2], size=_exploit_param, replace=False)
#     index = np.sort(index)
#     for each in index:
#         control_points_r[0] = np.concatenate((control_points_r[0],
#                                               inx[not count].control_points_r[pre_point:each]), axis=0)
#         control_points_r[1] = np.concatenate((control_points_r[1],
#                                               inx[count].control_points_r[pre_point:each]), axis=0)
#         count = not count
#         pre_point = each
#     off_spring = np.array([Individual(population, control_points_r[0]), Individual(population, control_points_r[1])])
#     if not int(_twins):
#         off_spring = np.delete(population.sort(off_spring), 1)
#     return off_spring


def ux(population, inx, _exploit_param):
    control_points_r = population.data[inx]
    ux_basis = np.array([0, 1])
    b = np.arange(0, population.num_cp, 1)
    index_ux = np.random.choice(ux_basis, (inx.size // 2, population.num_cp))
    index_ux = index_ux.repeat(2, axis=0).reshape(-1, index_ux.shape[1])
    index_ux[0:-1:2][:] = np.logical_not(index_ux[0:-1:2][:])
    for x in range(index_ux.shape[0] // 2):
        index_ux[2*x][:] += 2*x
        index_ux[2*x+1][:] += 2*x
    control_points_ux = control_points_r[index_ux, b]
    if inx.size % 2 != 0:
        control_points_ux = np.concatenate((control_points_ux, control_points_r[-1].reshape(1, population.data.shape[1], population.data.shape[2])))
    return control_points_ux


def ax(population, inx, _exploit_param):
    control_points_r = population.data[inx]
    x = np.arange(0, inx.size, 2)
    y = x + 1
    control_points_ax = control_points_r[x] * _exploit_param + control_points_r[y] * (1 - _exploit_param)

    return control_points_ax


def pso_exploit(population, inx, _exploit_param):
    """Individuals: list - two parts: individual including its personal_best, global_best"""
    control_points_r = population.data[inx]
    param_max = np.array([0.9, _exploit_param[1]])
    param_min = np.array([0.4, _exploit_param[0]])
    w, c_1 = param_max - (param_max - param_min) * population.generation / population.gen_max
    c_2 = param_max[1] + (param_max[1] - param_min[1]) * population.generation / population.gen_max
    r_1, r_2 = np.random.rand(2, inx.size)

    g_best = population.data[0]
    r_1 = np.repeat(r_1, g_best.size).reshape((inx.size,
                                              g_best.shape[0], g_best.shape[1]))
    r_2 = np.repeat(r_2, g_best.size).reshape((inx.size,
                                              g_best.shape[0], g_best.shape[1]))
    # TODO
    velocity = population.velocity[inx]
    p_best = population.p_best[inx]
    velocity = (w * velocity + c_1 * r_1 * (p_best - control_points_r) +
                c_2 * r_2 * (g_best - control_points_r))
    # velocity = []
    # for x in range(inx.size):
    #     velocity.append(w * population.individuals[inx[x]].velocity +
    #                     c_1 * r_1[x] * (population.individuals[inx[x]].p_best.control_points_r -
    #                                     population.data[inx[x]]) +
    #                     c_2 * r_2[x] * (g_best - population.data[inx[x]]))
    # velocity = np.array(velocity)
    new_control_points_r = control_points_r + velocity
    population.velocity = velocity
    return new_control_points_r


def safari(population, inx, _exploit_param):
    safari_wolves_inx = np.arange(0, np.int(population.num_individual * _exploit_param + 1), 1)
    safari_result = perturbation(population, safari_wolves_inx)
    leader_wolves = instantiation(population, safari_result)
    inx_wolves = population.sort(leader_wolves)
    g_best = safari_result[inx_wolves[0]]
    p_t = population.data[inx]
    a_ = g_best - p_t
    b_ = np.abs(a_)
    p_new = p_t + np.divide(a_, b_, out=np.zeros_like(a_), where=b_ != 0)
    return p_new


def perturbation(population, inx):
    control_points_r_safari = population.data[inx]
    disturbing_term = np.random.normal(0, 0.2, size=control_points_r_safari.shape)
    disturbing_term[:, :, 0] = 0
    disturbing_term[:, 0, :] = 0
    disturbing_term[:, -1, :] = 0
    control_points_r_safari += disturbing_term
    return control_points_r_safari


def commensalism(population, inx, _exploit_param, flag=0):
    tmp = 0
    if inx.size % 2 != 0:
        tmp = inx[-1]
        inx = inx[0:-1]
        flag = 1
    x = np.arange(0, inx.size, 2)
    y = x + 1
    p_i = population.data[inx[x]]
    p_j = population.data[inx[y]]
    g_best = population.data[0]
    r = eval(_exploit_param + "size=" + str(inx.size) + ")")
    r = np.repeat(r, g_best.size).reshape((-1, g_best.shape[0], g_best.shape[1]))
    r_1 = r[0: r.shape[0]//2]
    r_2 = r[r.shape[0]//2::]
    p_new_1 = p_i + r_1 * (g_best - p_j)
    p_new_2 = p_j + r_2 * (g_best - p_i)
    control_points_commensalism = np.array([p_new_1[0], p_new_2[0]])
    for x in range(1, p_new_1.shape[0]):
        control_points_commensalism = np.concatenate((control_points_commensalism, np.array([p_new_1[x], p_new_2[x]])))
    # individuals_commensalism = instantiation(population, control_points_commensalism)
    # for x in range(inx.size):
    #     if population.sort(np.array(
    #             [individuals_commensalism[x], population.individuals[inx[x]]]))[0] == 1:
    #         control_points_commensalism[x] = population.data[inx[x]].copy()
    if flag == 1:
        control_points_commensalism = np.concatenate((control_points_commensalism,
                                                      population.data[tmp].reshape(1, population.data[tmp].shape[0],
                                                                                   population.data[tmp].shape[1])))
    return control_points_commensalism


def de_rand(population, inx, _exploit_param):
    if not _exploit_param["q"]:
        q = population.num_individual
    else:
        q = _exploit_param["q"]
    c_r = np.random.normal(_exploit_param["u_cr"], 0.1, population.num_individual)
    x = np.random.rand(population.num_individual)
    f_origin = 0.1 * np.tan((x - 1 / 2) * np.pi) + _exploit_param["u_f"]
    f_origin[np.where(f_origin > 1)[0]] = 1
    f_origin[np.where(f_origin <= 0)[0]] = 0.2
    c_r = np.repeat(c_r, population.num_cp).reshape(population.num_individual, -1)
    f = np.repeat(f_origin, population.data[0].size).reshape(population.data.shape)
    q_selected = np.random.randint(0, q, inx.size//2)
    x_basis = np.arange(0, population.num_individual, 1)
    x_r1 = inx[0:population.num_individual]
    x_r2 = inx[population.num_individual::]
    v = population.data + f * (population.data[q_selected] - population.data[x_basis]) \
        + f * (population.data[x_r1] - population.data[x_r2])
    j_rand = np.random.randint(0, population.num_cp, size=population.num_individual)
    inx_origin = np.random.rand(population.num_individual, population.num_cp) >= c_r
    inx_origin[x_basis, j_rand] = 0
    cp_origin = np.where(inx_origin == 1)
    v[cp_origin] = population.data[cp_origin]
    c = _exploit_param["c"]
    population.soft_inf.exploit_param["u_cr"] = (1 - c) * _exploit_param["u_cr"]\
                                                 + c * (1 - np.sum(inx_origin) / inx_origin.size)
    population.soft_inf.exploit_param["u_f"] = (1 - c) * _exploit_param["u_f"]\
                                                + c * np.sum(f_origin**2) / np.sum(f_origin)
    return v


def de_best(population, inx, _exploit_param):
    if _exploit_param["q"] < 1:
        q = int(_exploit_param["q"] * population.num_individual) + 1
        _exploit_param["q"] = q
    return de_rand(population, inx, _exploit_param)

#
# def exploration(population, individuals, _explore, _explore_param, _infer):
#     if _explore == '000':
#         """Non-Uniform Mutation"""
#         off_spring = num(population, individuals, _explore_param, _infer)
#     elif _explore == '001':
#         """Uniform Mutation"""
#         off_spring = um(population, individuals, _explore_param, _infer)
#
#     elif _explore == '010':
#         """Gaussian Mutation"""
#         off_spring = gm(population, individuals, _explore_param, _infer)
#
#     elif _explore == '011':
#         """Cauchy Mutation"""
#         off_spring = cm(population, individuals, _explore_param, _infer)
#
#     elif _explore == '100':
#         """population updating strategy"""
#         off_spring = pus(population, individuals, _explore_param, _infer)
#
#     elif _explore == '101':
#         """simplified gray wolf optimizer"""
#         off_spring = sgwo(population, individuals, _explore_param, _infer)
#
#     elif _explore == '110':
#         """collective information"""
#         off_spring = cinf(population, individuals, _explore_param, _infer)
#
#     else:
#         """None"""
#         off_spring = individuals
#
#     return off_spring


# def infer(population, genomes, variants):
#     count = 0
#     for variant in variants:
#         # if penalty_function(population.gen_max, variant.fitness_wight_factor,
#         #                     variant.constraint, population.generation, '000') > \
#         #         penalty_function(population.gen_max, genomes[count].fitness_wight_factor,
#         #                          genomes[count].constraint, population.generation, '000'):
#         if 1:
#             # TODO
#             variants[count] = genomes[count]
#         count += 1
#     return variants


def fixed_pm_1(num_cp, gen):
    return 0.5 / num_cp, 1


def fixed_pm_2(num_cp, gen):
    return 0.5 / num_cp, 2


def adaptive_pm_1(num_cp, gen):
    return 0.5 / num_cp * np.log2(gen+1), 1


def adaptive_pm_2(num_cp, gen):
    return 0.5 / num_cp * np.log2(gen+1), 2


def num(population, genomes, _explore_param):
    pm, theta = eval(_explore_param)(population.num_cp, population.generation)
    r_ = np.random.rand(genomes.shape[0], genomes.shape[1] - 2)
    inx = np.where(r_ < pm) + np.array([0, 1]).reshape(2, 1)
    inx = (inx[0], inx[1])
    x = np.zeros(inx[0].size)
    y = np.random.uniform(-theta, theta, size=inx[0].size)
    z = np.random.uniform(-theta, theta, size=inx[0].size)
    disturb = np.array([x, y, z]).T
    variant = copy.deepcopy(genomes)
    variant[inx] += disturb
    return variant


def um(population, genomes, _explore_param):
    pm, theta = eval(_explore_param)(population.num_cp, population.generation)
    variant = copy.deepcopy(genomes)
    r_ = np.random.rand(genomes.shape[0], genomes.shape[1] - 2)
    inx_pre = np.where(r_ < pm)
    inx = inx_pre + np.array([0, 1]).reshape(2, 1)
    inx = (inx[0], inx[1])
    delta_l = variant[0][1][0] - 0
    size_ = inx[0].size
    x = np.zeros(size_)
    if theta == 1:
        y = np.random.uniform(-delta_l, delta_l, size=size_)
        z = np.random.uniform(-delta_l, delta_l, size=size_)
    else:
        y = np.random.normal(0, delta_l / 3, size=size_)
        z = np.random.normal(0, delta_l / 3, size=size_)
    disturb = np.array([x, y, z]).T
    variant[inx] += disturb
    # for each in variant:
    #     for cnt in range(1, population.num_cp - 1):
    #         if np.random.rand() < population.explore_param[1]:
    #             if population.explore_param[2] == 1:
    #                 x = each[cnt-1][0] + np.random.uniform(-delta_l,  delta_l)
    #                 y = variant[cnt-1][1] + np.random.uniform(-delta_l, delta_l)
    #                 z = variant[cnt-1][2] + np.random.uniform(-delta_l, delta_l)
    #             else:
    #                 x = variant[cnt-1][0] + np.random.normal(0, delta_l / 3)
    #                 y = variant[cnt-1][1] + np.random.normal(0, delta_l / 3)
    #                 z = variant[cnt-1][2] + np.random.normal(0, delta_l / 3)
    #             variant[cnt] = np.array([x, y, z])
    #     variants[count] = Individual(population, variant)
    #     count += 1
    #
    # if not int(_infer):
    #     variants = infer(population, genomes, variants)
    return variant


def gm(population, genomes, _explore_param):
    pm, theta = eval(_explore_param)(population.num_cp, population.generation)
    r_ = np.random.rand(genomes.shape[0], genomes.shape[1] - 2)
    inx = np.where(r_ < pm) + np.array([0, 1]).reshape(2, 1)
    inx = (inx[0], inx[1])
    x = np.zeros(inx[0].size)
    y = np.random.normal(0, theta / 3, size=inx[0].size)
    z = np.random.normal(0, theta / 3, size=inx[0].size)
    disturb = np.array([x, y, z]).T
    variant = copy.deepcopy(genomes)
    variant[inx] += disturb
    return variant


def cm(population, genomes, _explore_param):
    pm, theta = eval(_explore_param)(population.num_cp, population.generation)
    r_ = np.random.rand(genomes.shape[0], genomes.shape[1] - 2)
    inx = np.where(r_ < pm) + np.array([0, 1]).reshape(2, 1)
    inx = (inx[0], inx[1])
    x = np.zeros(inx[0].size)
    y = theta * np.random.standard_cauchy(inx[0].size)
    z = theta * np.random.standard_cauchy(inx[0].size)
    disturb = np.array([x, y, z]).T
    variant = copy.deepcopy(genomes)
    variant[inx] += disturb
    return variant


def pus(population, genomes, _explore_param):
    size = genomes.shape[0]//2
    variant = copy.deepcopy(genomes)
    if genomes.shape[0] % 2 != 0:
        variant[size::] = num(population, genomes[0:size+1], _explore_param)
        population.velocity[size::] = population.velocity[0:size+1]
    else:
        variant[size::] = num(population, genomes[0:size], _explore_param)
        population.velocity[size::] = population.velocity[0:size]
    return variant


def sgwo(population, genomes, _explore_param):
    r = np.random.rand(genomes.shape[0])
    coe_a = 2 - 2 * population.generation / population.gen_max
    coe_c = 2 * r
    coe_upper_a = (2 * r - 1) * coe_a
    d = np.abs(coe_c.repeat(genomes[0].size).reshape(genomes.shape) *\
        genomes[0].reshape(1, -1).repeat(genomes.shape[0], axis=0).reshape(genomes.shape) - genomes)
    d[:, :, 0] = 0
    d[:, 0, :] = 0
    d[:, -1, :] = 0
    variant = genomes - coe_upper_a.repeat(genomes[0].size).reshape(genomes.shape) * d
    return variant


def cinf(population, genomes, _explore_param):
    return genomes


def none_explore(population, genomes, _explore_param):
    return genomes


if __name__ == '__main__':
   pass