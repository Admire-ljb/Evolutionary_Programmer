from sort_selection import *
import copy


def exploitation(population, individuals, _exploit, _exploit_param, _twins):
    if _exploit == '000':
        """nPX"""
        off_spring = npx(population, individuals, _exploit_param, _twins)
    elif _exploit == '001':
        """UX"""
        off_spring = ux(population, individuals, _exploit_param, _twins)

    elif _exploit == '010':
        """AX"""
        off_spring = ax(population, individuals, _exploit_param, _twins)

    elif _exploit == '011':
        """PSO"""
        off_spring = pso_exploit(population, individuals, _exploit_param, _twins)

    elif _exploit == '100':
        """safari"""
        off_spring = safari(population, individuals, _exploit_param, _twins)

    elif _exploit == '101':
        """commensalism"""
        off_spring = commensalism(population, individuals, _exploit_param, _twins)

    elif _exploit == '110':
        """DE/Rand"""
        off_spring = de_rand(population, individuals, _exploit_param, _twins)

    else:
        """DE/Best"""
        off_spring = de_best(population, individuals, _exploit_param, _twins)

    return off_spring


def twins(population, off_spring,):
    if penalty_function(population.gen_max, off_spring[0].fitness_wight_factor,
                        off_spring[0].constraint, population.generation, '000') > \
            penalty_function(population.gen_max, off_spring[1].fitness_wight_factor,
                             off_spring[1].constraint, population.generation, '000'):
        key = 0
    else:
        key = 1
    return key


def npx(population, individuals, _exploit_param, _twins):
    if population.exploit_param is None:
        if _exploit_param == '00':
            population.exploit_param = ['nPX', 1]
        if _exploit_param == '01':
            population.exploit_param = ['nPX', 2]
        if _exploit_param == '10':
            population.exploit_param = ['nPX', 3]
        if _exploit_param == '11':
            population.exploit_param = ['nPX', 4]
    points = []
    control_points = [individuals[0].control_points[0].reshape(1, 3),
                      individuals[1].control_points[0].reshape(1, 3)]
    pre_point = 1
    count = False
    for cnt in range(population.exploit_param[1]):
        index = np.random.randint(2, population.num_cp)
        if index not in points:
            points.append(index)
    points.append(population.num_cp)
    points.sort()
    for each in points:
        control_points[0] = np.concatenate((control_points[0],
                                            individuals[not count].control_points[pre_point:each]), axis=0)
        control_points[1] = np.concatenate((control_points[1],
                                            individuals[count].control_points[pre_point:each]), axis=0)
        count = not count
        pre_point = each
    off_spring = [Individual(population, control_points[0]), Individual(population, control_points[1])]
    if not int(_twins):
        key = twins(population, off_spring)
        off_spring.pop(key)
    return off_spring


def ux(population, individuals, _exploit_param, _twins):
    if population.exploit_param is None:
        if _exploit_param == '00':
            population.exploit_param = ['UX', 0.5]
        if _exploit_param == '01':
            population.exploit_param = ['UX', 0.6]
        if _exploit_param == '10':
            population.exploit_param = ['UX', 0.7]
        if _exploit_param == '11':
            population.exploit_param = ['UX', 0.8]

    control_points = [individuals[0].control_points[0].reshape(1, 3),
                      individuals[1].control_points[0].reshape(1, 3)]
    for cnt in range(1, population.num_cp):
        if np.random.rand() < population.exploit_param[1]:
            control_points[0] = np.concatenate((control_points[0],
                                                individuals[1].control_points[cnt:cnt+1]), axis=0)
            control_points[1] = np.concatenate((control_points[1],
                                                individuals[0].control_points[cnt:cnt+1]), axis=0)
        else:
            control_points[0] = np.concatenate((control_points[0],
                                                individuals[0].control_points[cnt:cnt+1]), axis=0)
            control_points[1] = np.concatenate((control_points[1],
                                                individuals[1].control_points[cnt:cnt+1]), axis=0)
    off_spring = [Individual(population, control_points[0]), Individual(population, control_points[1])]
    if not int(_twins):
        key = twins(population, off_spring)
        off_spring.pop(key)
    return off_spring


def ax(population, individuals, _exploit_param, _twins):
    off_spring = []
    # TODO
    return off_spring


def pso_exploit(population, individuals, _exploit_param, _twins):
    off_spring = []
    # TODO
    return off_spring


def safari(population, individuals, _exploit_param, _twins):
    off_spring = []
    # TODO
    return off_spring


def commensalism(population, individuals, _exploit_param, _twins):
    off_spring = []
    # TODO
    return off_spring


def de_rand(population, individuals, _exploit_pram, _twins):
    off_spring = []
    # TODO
    return off_spring


def de_best(population, individuals, _exploit_param, _twins):
    off_spring = []
    # TODO
    return off_spring


def exploration(population, individuals, _explore, _explore_param, _infer):
    if _explore == '000':
        """Non-Uniform Mutation"""
        off_spring = num(population, individuals, _explore_param, _infer)
    elif _explore == '001':
        """Uniform Mutation"""
        off_spring = um(population, individuals, _explore_param, _infer)

    elif _explore == '010':
        """Gaussian Mutation"""
        off_spring = gm(population, individuals, _explore_param, _infer)

    elif _explore == '011':
        """Cauchy Mutation"""
        off_spring = cm(population, individuals, _explore_param, _infer)

    elif _explore == '100':
        """population updating strategy"""
        off_spring = pus(population, individuals, _explore_param, _infer)

    elif _explore == '101':
        """simplified gray wolf optimizer"""
        off_spring = sgwo(population, individuals, _explore_param, _infer)

    elif _explore == '110':
        """collective information"""
        off_spring = cinf(population, individuals, _explore_param, _infer)

    else:
        """None"""
        off_spring = individuals

    return off_spring


def infer(population, genomes, variants):
    count = 0
    for variant in variants:
        if penalty_function(population.gen_max, variant.fitness_wight_factor,
                            variant.constraint, population.generation, '000') > \
                penalty_function(population.gen_max, genomes[count].fitness_wight_factor,
                                 genomes[count].constraint, population.generation, '000'):
            variants[count] = genomes[count]
        count += 1
    return variants


def um(population, genomes, _explore_param, _infer):
    if population.explore_param is None:
        if _explore_param == '00':
            population.explore_param = ['UM', 0.5 / population.num_cp, 1]
        if _explore_param == '01':
            population.explore_param = ['UM', 0.5 / population.num_cp, 2]
        if _explore_param == '10':
            population.explore_param = ['UM', 0.5 / population.num_cp * np.log2(population.generation), 1]
        if _explore_param == '11':
            population.explore_param = ['UM', 0.5 / population.num_cp * np.log2(population.generation), 2]
    variants = copy.deepcopy([genomes[x].control_points for x in range(len(genomes))])
    delta_l = variants[0][1][0] - variants[0][0][0]
    count = 0
    for variant in variants:
        for cnt in range(1, population.num_cp - 1):
            if np.random.rand() < population.explore_param[1]:
                if population.explore_param[2] == 1:
                    x = variant[cnt-1][0] + np.random.uniform(-delta_l,  delta_l)
                    y = variant[cnt-1][1] + np.random.uniform(-delta_l, delta_l)
                    z = variant[cnt-1][2] + np.random.uniform(-delta_l, delta_l)
                else:
                    x = variant[cnt-1][0] + np.random.normal(0, delta_l / 3)
                    y = variant[cnt-1][1] + np.random.normal(0, delta_l / 3)
                    z = variant[cnt-1][2] + np.random.normal(0, delta_l / 3)
                variant[cnt] = np.array([x, y, z])
        variants[count] = Individual(population, variant)
        count += 1

    if not int(_infer):
        variants = infer(population, genomes, variants)
    return variants


def num(population, genomes, _explore_param, _infer):
    if population.explore_param is None:
        if _explore_param == '00':
            population.explore_param = ['NUM', 0.5 / population.num_cp, 1]
        if _explore_param == '01':
            population.explore_param = ['NUM', 0.5 / population.num_cp, 2]
        if _explore_param == '10':
            population.explore_param = ['NUM', 0.5 / population.num_cp * np.log2(population.generation), 1]
        if _explore_param == '11':
            population.explore_param = ['NUM', 0.5 / population.num_cp * np.log2(population.generation), 2]
    variants = copy.deepcopy([genomes[x].control_points for x in range(len(genomes))])
    count = 0
    for variant in variants:
        for cnt in range(1, population.num_cp - 1):
            if np.random.rand() < population.explore_param[1]:
                x = 0
                y = np.random.uniform(-population.explore_param[2], population.explore_param[2])
                z = np.random.uniform(-population.explore_param[2], population.explore_param[2])
                variant[cnt] += np.array([x, y, z])
        variants[count] = Individual(population, variant)
        count += 1

    if not int(_infer):
        variants = infer(population, genomes, variants)
    return variants


def gm(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def cm(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def pus(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def sgwo(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


def cinf(population, individuals, _explore_param, _infer):
    off_spring = []
    # TODO
    return off_spring


if __name__ == '__main__':
    p = test()
    individual = []
    sort(p, '10', '111')
    for i in range(2):
        individual.append(selection(p, '10', '11'))
    off_springs = exploitation(p, individual, '001', '10', '0')
    variants = exploration(p, individual, '000', '00', '0')